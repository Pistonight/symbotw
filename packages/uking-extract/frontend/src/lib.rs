use std::fs::File;
use std::io::BufReader;

use uking_extract_common::ProgressPrinter;

mod cli;
mod python;
mod tyyaml;
pub use cli::*;

use python::Bundler;
use tyyaml::{Address, DataSheet};

pub fn run(options: &Options) -> anyhow::Result<()> {
    let input_path_str = options.input.display().to_string();
    println!("Reading data from {}", input_path_str);
    let file = File::open(&options.input)?;
    let mut reader = BufReader::new(file);
    let data_sheet: DataSheet = serde_yaml_ng::from_reader(&mut reader)?;

    let mut header = String::new();
    header.push_str(include_str!("../../LICENSE"));
    header.push_str("\n\n");
    header.push_str(include_str!("../README.md"));
    header.push_str("\n\n");
    header.push_str("This script is generated by using the data and options below:\n");

    header.push_str("//////////// Options ////////////\n");
    header.push_str(&format!(
        "# Data file: {}\n",
        options.input.display().to_string().replace('\\', "\\\\")
    ));
    if !options.pattern.is_empty() {
        header.push_str(&format!("# Pattern: {}\n", options.pattern));
    }
    if options.type_only {
        header.push_str("# Type only\n");
    }
    if options.name_only {
        header.push_str("# Name only\n");
    }
    if options.skip_types {
        header.push_str("# Skip types\n");
    }
    header.push_str(&format!("# Upper Address: 0x{:08X}\n", options.address));
    if options.verbose > 0 {
        header.push_str(&format!("# Verbosity {}\n", options.verbose));
    }

    let mut main_script = String::new();
    // create the frontend
    main_script.push_str("def get_frontend():\n");
    let frontend_class = match options.frontend {
        Frontend::IDA => "IDAFrontend",
    };
    main_script.push_str(&format!("    return {}()\n", frontend_class));

    // the import types
    main_script.push_str("def process_imports(ti, ai):\n");
    if options.skip_types {
        main_script.push_str("    ti.skip()\n");
    }
    main_script.push_str(&format!("    ai.set_upper(0x{:08X})\n", options.address));

    if !options.name_only && !options.skip_types {
        let progress = ProgressPrinter::new(data_sheet.enums.len(), "Load enums");
        for (i, def) in data_sheet.enums.iter().enumerate() {
            progress.print(i, &def.name);
            for line in def.emit_python() {
                main_script.push_str(&format!("    {}\n", line));
            }
        }
        progress.done();

        let progress = ProgressPrinter::new(data_sheet.unions.len(), "Load unions");
        for (i, def) in data_sheet.unions.iter().enumerate() {
            progress.print(i, &def.name);
            for line in def.emit_python() {
                main_script.push_str(&format!("    {}\n", line));
            }
        }
        progress.done();

        let progress = ProgressPrinter::new(data_sheet.structs.len(), "Load structs");
        for (i, def) in data_sheet.structs.iter().enumerate() {
            progress.print(i, &def.name);
            for line in def.emit_python() {
                main_script.push_str(&format!("    {}\n", line));
            }
        }
        progress.done();

        main_script.push_str(&format!("    ti.run_import(\"{}\")\n", options.pattern));
    }

    if !options.type_only {
        let progress = ProgressPrinter::new(data_sheet.addresses.len(), "Load symbols");
        for (i, (offset, def)) in data_sheet.addresses.iter().enumerate() {
            match def {
                Address::Function(func) => {
                    progress.print(i, &func.name);
                    for line in func.emit_python(offset) {
                        main_script.push_str(&format!("    {}\n", line));
                    }
                }
                Address::Data(data) => {
                    progress.print(i, &data.name);
                    let s = data.emit_python(offset);
                    main_script.push_str(&format!("    {}\n", s));
                }
            }
        }
        progress.done();

        let name_only = if options.name_only { "True" } else { "False" };
        main_script.push_str(&format!(
            "    ai.run_import({}, \"{}\")\n",
            name_only, options.pattern
        ));
    }

    main_script.push_str("if __name__ == '__main__':\n");
    main_script.push_str(&format!(
        "    run_with_frontend({}, get_frontend(), process_imports)\n",
        options.verbose
    ));

    // bundle the scripts
    let mut bundler = Bundler::new();
    bundler.set_header(header);
    bundler.import_frontend(options.frontend);
    let output = bundler.bundle(&main_script)?;

    uking_extract_common::ensure_parent_exists(&options.output)?;

    let output_path_str = options.output.display().to_string();
    std::fs::write(&options.output, output)?;
    println!("Script saved to {}", output_path_str);
    println!(
        "Please make sure to run the script AFTER auto-analysis is complete in a fresh database."
    );

    Ok(())
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, clap::ValueEnum)]
pub enum Frontend {
    IDA,
}
