use std::num::ParseIntError;
use std::path::PathBuf;

use error_stack::{report, Report, ResultExt};

use crate::Frontend;

#[derive(Debug, Clone, clap::Parser)]
pub struct CLI {
    /// (Optional) Input path of the data file generated by `ukingidatool extract`
    ///
    /// If not specified and the current directory is a subdirectory of
    /// the botw decompile project, the input path will be set to `<botw>/build/uking-extract.yaml`
    pub input: Option<String>,

    /// The frontend to use
    #[clap(long)]
    pub frontend: Frontend,
    /// Output path of the generated Python script.
    ///
    /// If not specified and the current directory is a subdirectory of
    /// the botw decompile project, the output path will be set to `<botw>/build/uking-import.py`
    #[clap(short, long)]
    pub output: Option<String>,
    /// Only import symbols and types whose name contains this substring. Note
    /// that for decompiled functions, the mangled name is used.
    ///
    /// Dependent types are still imported recursively
    #[clap(short, long)]
    pub pattern: Option<String>,
    /// Only import types. Don't import address symbols
    #[clap(long)]
    pub type_only: bool,
    /// Specify the upper 8 bytes of the address. For example `-a 0x00`.
    ///
    /// The default is 0x71 to be consistent with the botw decompile project
    #[clap(short, long, default_value = "0x71", value_parser = parse_number)]
    pub address: u32,
    /// Only import names of the address symbols. Don't import any type
    ///
    /// This exists as an alternative to running the rename script in the botw decompile
    /// project. It will also import data symbols, but will not rename function arguments.
    #[clap(long, conflicts_with = "type_only", conflicts_with = "pattern")]
    pub name_only: bool,

    /// Assume types are already imported. The generated script will error if types are not already imported.
    ///
    /// This is useful if you have already imported with `--type-only`
    #[clap(
        long,
        conflicts_with = "name_only",
        conflicts_with = "type_only",
        conflicts_with = "pattern"
    )]
    pub skip_types: bool,

    /// Verbosity level
    ///
    /// `-v1` will print member info. `-v2` will print member info and renaming info
    #[clap(short, long, default_value = "0")]
    pub verbose: u32,
}

fn parse_number(s: &str) -> std::result::Result<u32, ParseIntError> {
    if let Some(s) = s.strip_prefix("0x") {
        u32::from_str_radix(s, 16)
    } else {
        s.parse()
    }
}

/// Options parsed from CLI
pub struct Options {
    pub frontend: Frontend,
    pub input: PathBuf,
    pub output: PathBuf,
    pub pattern: String,
    pub type_only: bool,
    pub address: u32,
    pub name_only: bool,
    pub skip_types: bool,
    pub verbose: u32,
}

impl TryFrom<CLI> for Options {
    type Error = Report<Error>;

    fn try_from(value: CLI) -> Result<Self, Self::Error> {
        let (input, output) = match (value.input, value.output) {
            (Some(input), Some(output)) => (input.into(), output.into()),
            (i, o) => {
                let botw = uking_extract_common::find_botw()
                    .ok_or(Error::BotwNotFound)
                    .attach_printable("Please specify --input and --output manually")?;
                let input = i.map_or_else(
                    || botw.join("build").join("uking-extract.yaml"),
                    PathBuf::from,
                );
                let output =
                    o.map_or_else(|| botw.join("build").join("uking-import.py"), PathBuf::from);
                (input, output)
            }
        };
        if !input.exists() {
            return Err(report!(Error::DataNotFound))
                .attach_printable(format!("Trying to read file: {}", input.display()))
                .attach_printable(
                    "If you haven't already, run `ukingidatool extract` to generate the data file.",
                )
                .attach_printable("Or, specify the input file manually with `--input`.");
        }
        Ok(Self {
            frontend: value.frontend,
            input,
            output,
            pattern: value.pattern.unwrap_or_default(),
            type_only: value.type_only,
            address: value.address,
            name_only: value.name_only,
            skip_types: value.skip_types,
            verbose: value.verbose,
        })
    }
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Botw decompile project not found.")]
    BotwNotFound,
    #[error("Data file not found!")]
    DataNotFound,
}
